# 027API修改注意事项



## 角色部分的改动

1.换装方式变更：在前面的版本，换装确实是一件麻烦事，API更新之前需要经过：获取角色装扮信息、设置角色装扮信息外观类型、设置角色装扮、等待角色外观设置完毕等一系列流程才能成功完成一次换装，这次更新后流程将极大的简化！具体更改内容有以下几点：

- `getAppearance() `以及 `setAppearance()`被去掉，原角色外观对象替换为`CharacterDescription`。可以直接通过`character.description`进行调用

原换装方式：

```TypeScript
Gameplay.asyncGetCurrentPlayer().then((p: Gameplay.Player) => {
    let hv2 = p.character.setAppearance(Gameplay.HumanoidV2);
    hv2.setAppearanceData([CharGuid], () => {
        p.character.setAppearance(Gameplay.HumanoidV2)；
        p.character.getAppearance(Gameplay.HumanoidV2).appearanceSync();
    })
}
```

现换装方式：

```TypeScript
Gameplay.asyncGetCurrentPlayer().then((p: Gameplay.Player) => {
    //角色换装
    p.character.setDescription([CharGuid]);
    //将角色装扮同步给其他客户端
    p.character.syncDescription()
})
```

- 使用`getDescription()`可以获取当前外观数据的拷贝，并且修改这个拷贝值并不会影响当前角色外观。需要将当前角色外观数据应用于其他角色时可以使用此方法（例如领奖台的实现）。

- 角色外观异步等待函数`appearanceReady`替换为**GameObject**中`asyncReady`。对角色的一切操作，最好都等一下`asyncReady()`，如头顶UI，mesh，胶囊体，切换摄像机父级对象等。

- 角色换装完成委托统一整合为`onDescriptionComplete`。

  -  **注意**：同步外观数据`syncDescription`后会再次调用`onDescriptionComplete`。避免在`onDescriptionComplete`委托方法中执行外观数据同步，造成无限循环。

  - ```TypeScript
    /** 错误写法*/
    this.localPlayer.character.setDescription([appearanceGuid]);
    this.localPlayer.character.onDescriptionComplete.add(()=>{
        //在委托中使用同步
        this.localPlayer.character.syncDescription();
    })
    
    /** 正确写法*/
    this.localPlayer.character.setDescription([appearanceGuid]);
    //设置完外观直接同步
    this.localPlayer.character.syncDescription();
    ```

2.外观类型删除：NPC、Humanoid等类型都被删掉了，现在人形对象不会分成V1、V2、NPC等各种类型，而是统一为Character，使管理人形对象变得更加方便。现在判断一个character是不是NPC可以用更加符合其定义的方式：`(obj instanceof mw.Character)&&(obj.player === null)`来判断obj是不是NPC(Non-Player Character)

原判断方式：

```TypeScript
//判断角色为NPC
obj1 instanceof Gameplay.NPC
//判断角色为玩家角色
obj2 instanceof Gameplay.Character
```

现判断方式：

```TypeScript
//判断角色为NPC
(obj1 instanceof mw.Character)&&(obj2.player === null)
//判断角色为玩家角色
(obj1 instanceof mw.Character)&&(obj2.player !== null)
```

3.player之前可以直接获得或者修改character的属性及函数，为了能够更好的区分player和character的职责，在027更新之后做了限制：必须获取character才能够对其属性与函数作出修改，之前直接从player获取worldLocation例如：

```TypeScript
player.worldLocation
```

在更新后需要变为

```TypeScript
player.character.worldLocation
```

4.旧版本当character隐藏时，其slot关联的对象不会被隐藏，这就导致如果需要完全隐藏玩家需要手动隐藏所有其slot关联的对象。在版本更新后，character隐藏时其slot关联的对象也会被一起隐藏。这就导致在更新版本后，旧工程中与character的slot关联的对象都会被隐藏，如果需要维持旧版本的表现，可以尝试以下修改。

原方法：

```TypeScript
character.setVisibility(PropertyStatus.Off,true)
//027更新后此处xmodel设置为slot之后会被隐藏
//如果需要设置slot但是仍旧显示需要看新用法
character.attachToSlot(this.xmodel,mw.HumanoidSlotType.Root)
```

现方法：

```TypeScript
//将方法后面的“是否同步子物体”设置为false
character.setVisibility(PropertyStatus.Off,false)
//通过parent绑定两个物体
this.xmodel.parent = character
```

5.角色不再自动进行rpc同步。之前版本中，角色在客户端做更改后会自动同步其他角色包括动画、姿态等多种属性，当角色多了之后RPC可能会过于频繁而使游戏经常卡顿导致表现不佳。本次更新之后将取消客户端属性更改时的大量RPC同步，需要同步的操作可以在服务端实现。

玩家角色只有`Transform`属性(`position`, `rotation`, `scale`)在主控端(该角色的客户端)修改会同步。服务端修改会通知主控端执行移动。

除了`Transform`之外其他属性都将不再同步，例如：动画，姿态，头顶名字，布娃娃状态，胶囊体偏移等，这些属性都需要在服务端做相对应的修改。

非玩家角色NPC仅在服务端修改会同步，这可能会造成在客户端修改NPC位置后被拉回服务端位置(一般是NPC生成点),例如：

<video controls src="https://arkimg.ark.online/MetaApp20231007-164126%20-%20Trim.mp4"></video>

若遇到此问题，可尝试在代码中将修改NPC位置在服务端上运行，或者将NPC改为客户端对象。

![img](https://arkimg.ark.online/1697021058418-42.webp)

​															修改前**

![img](https://arkimg.ark.online/1697021058408-1.webp)

​															**修改后**

`userId`将作为Player下的成员，可以直接使用`player.userId`来获取，同时需要检查旧工程中有没有使用同名变量的情况，若出现同名变量并且对其进行了设置，则会在服务端出现报错，例如：

![img](https://arkimg.ark.online/1697021058408-2.webp)

若代码中有类似情况，可以将原代码中的userId变量名替换为非重名的名字，或者直接将设置userId的代码删除即可。

## 天空盒部分的改动

在新版编辑器上，天空盒的操作也更为简化。现在操作天空盒将不再需要提前查找,可以直接在`mw.Skybox`下对天空盒进行操作。

原操作天空盒方式：

```TypeScript
let skyBox: Gameplay.SkyBox
//需要先查找天空盒这个物体才能操作
skyBox = await Core.GameObject.asyncFind('天空盒的gameObjectId') as Gameplay.SkyBox
if(skyBox){
    skyBox.skyDomeTextureAssetByID = '101570'
    skyBox.cloudEnable = false
}
```

现操作天空盒方式：

```TypeScript
//可以直接在mw.Skybox下进行操作
mw.Skybox.skyDomeTextureID = '101570'
mw.Skybox.cloudVisible = false
```

## 模块框架通信（net_方法）改动

现在编辑器中的模块管理框架在双端通信的传输参数上面做了一点修改，原来net_方法中`player？`这个可变参数如果不传，系统会默认为调用该方法的客户端的player，这个特性在027上将被取消，例如：

```TypeScript
/**服务端模块错误示范*/
public net_test(player?: mw.Player){
    //如果player不传参数，此处无法获取player
    this.getClint(player)
}
```

类似的代码将无法获取player。正确的传输player方法：

```TypeScript
/**服务端模块*/
public net_getPlayer(playerId: number){
    //使用playerId进行传输
    const player = mw.Player.getPlayer(playerId);
    //在服务端net_方法中调用，可以拿到调用该方法的服务端的player
    const player2 = this.currentPlayer;
    }
```

大家在升级完旧工程后可能会遇到运行时某些功能不起反应，例如升级后出现关卡无法记录，背包物品无法使用等情况，并且有类似"Cannot read Property 'XXX' of null"报错显示错误位置在net_方法下，如：

![img](https://arkimg.ark.online/1697021058408-3.webp)

可以检查一下代码中的RPC通信方法参数中有没有使用`player？`”的情况。

## 摄像机部分改动

本次更新后，相机位置模式的作用将更加明确，方便大家理解如何操作摄像机。同时修改了相机位置模式的部分默认设置，使其更加合理易用。摄像机部分的更新可能会导致可能之前调好的部分摄相机出现偏移，若升级项目之后发现相机位置出现了偏移，可以排查以下情况：

1.相机旋转模式`cameraRotationMode`，现替换为了`rotationMode`。在原来版本中设置为"旋转固定"时，摄像机会将世界旋转设置成(0,0,0)从而出现一个突然的偏移。在027升级后将`rotationMode`设置为"旋转固定"时，将会沿用上一帧控制器的旋转值(摄像机相对于挂载对象的旋转)。在升级编辑器版本之后如果相机旋转出现混乱，可以在原代码上做以下更改。

旧版本代码：

```TypeScript
//获取相机
let camera = this.currentPlayer.character.cameraSystem;
camera.cameraRotationMode = Gameplay.CameraRotationMode.RotationFixed;
//此处相机世界旋转会设为(0,0,0)
let transform = new Type.Transform();
transform.location = new Type.Vector(-940, -554.5, 168);
transform.rotation = new Type.Rotation(-9, -4.5, 29);
camera.cameraRelativeTransform = transform;
```

修改后代码：

```TypeScript
//获取相机
let camera = Camera.currentCamera;
camera.rotationMode = mw.CameraRotationMode.RotationControl;
//此处相机世界旋转不会自动设为(0,0,0)，故旧工程升级时若需要维持之前的效果，需要手动设置
this.getCamera.springArm.worldTransform.rotation = Rotation.zero
//后续正常操作
let transform = new mw.Transform();
transform.position = new mw.Vector(-940, -554.5, 168);
transform.rotation = new mw.Rotation(-9, -4.5, 29);
camera.localTransform = transform;
```

2.相机位置模式`cameraLocationMode`,现替换为了`positionMode`。在原来版本中设置为"位置固定"时，摄像机会使用弹簧臂的相对坐标作为世界位置(零点位置加上弹簧臂偏移)。在027升级后将`positionMode`设置为"位置固定"时，将会直接沿用上一帧世界位置。在升级编辑器版本之后如果相机位置出现混乱，可以在原代码上做以下更改。

旧版本代码：

```TypeScript
//获取相机
let camera = this.currentPlayer.character.cameraSystem;
camera.cameraLocationMode = Gameplay.CameraLocationMode.LocationFixed;
//此处相机世界坐标会设为相机弹簧臂偏移值
let transform = new Type.Transform();
transform.location = new Type.Vector(-940, -554.5, 168);
transform.rotation = new Type.Rotation(-9, -4.5, 29);
camera.cameraRelativeTransform = transform;
```

修改后代码：

```TypeScript
//获取相机
let camera = Camera.currentCamera;
//在切换模式前先记录摄像机弹簧臂的相对偏移
let tempOffset = camera.springArm.localTransform.position;
camera.positionMode = mw.CameraPositionMode.PositionFixed;
//此处相机世界坐标不会设为相机弹簧臂偏移值，故旧工程升级时若需要维持之前的效果，需要手动设置
camera.springArm.localTransform.position = tempOffset;
//后续正常操作
let transform = new mw.Transform();
transform.position = new mw.Vector(-940, -554.5, 168);
transform.rotation = new mw.Rotation(-9, -4.5, 29);
camera.localTransform = transform;
```

## 交互物部分的改动

1.交互位置更加准确

本次升级之后，交互物的交互位置会在交互物的坐标处，这样大家之后在调整交互位置的时候能更方便地找到交互点。同时会导致在旧工程升级后，可能会出现交互物交互位置偏移的情况，例如：

![img](https://arkimg.ark.online/1697021058408-4.webp)

​															**修改前**

此时只需要修改交互物坐标即可解决

![img](https://arkimg.ark.online/1697021058409-5.webp)![img](https://arkimg.ark.online/1697021058409-6.webp)

​														**修改后**

2.交互结束成功的逻辑需要用事件委托

在新版本中，使用`mw.Interactor.leave()`结束交互后，为了保证已经完全退出交互，需要使用需要使用`onLeave`委托来执行退出交互物之后的逻辑。

结束交互旧用法：

```TypeScript
//旧用法
let isExitSuceed = await this.interactivitys[triggerIndex].leave(this.curPlayers[triggerIndex].character.worldTransform.position)
if (!isExitSuceed) return;
//后续逻辑 
```

结束交互新用法：

```TypeScript
//新用法
let isExitSuceed = this.interactivitys[triggerIndex].leave(this.curPlayers[triggerIndex].character.worldTransform.position)
if (!isExitSuceed) return;

this.interactivitys[triggerIndex].onLeave.add(()=>[
    //后续逻辑
])
```

## Util命名空间变更

- 情况1

在027之前的版本，部分Util相关接口处于特定的命名空间之下

![img](https://arkimg.ark.online/1697021058409-7.webp)

​															**026版本**

我们使用相关接口写出来的代码是如下情况

![img](https://arkimg.ark.online/1697021058409-8.webp)

​															**026版本**

在027中，有不少接口直接在mw命名空间之下了，写法改为如下情况

![img](https://arkimg.ark.online/1697021058409-9.webp)

​															**027版本**

关键字案例：mw.TweenUtil.EasingFunction修改为mw.TweenEasingFunction

- 情况2

![img](https://arkimg.ark.online/1697021058409-10.webp)

​															**026版本**

![img](https://arkimg.ark.online/1697021058409-11.webp)

​															**027版本**

SystemUtil改为了类并且从Util命名空间移动到了mw命名空间之下，因此写法也产生了改变：

![img](https://arkimg.ark.online/1697021058409-12.webp)

​															**026版本**

![img](https://arkimg.ark.online/1697021058409-13.webp)

​															**027版本**

## 其它情况修改

### 由于重名导致的自动升级的错误替换

如果出现了下列类似情况或一段代码看不出问题来，可以通过备份的026项目，比对原本代码与新代码的情况，自动替换出现了非接口替换情况的话，很可能就是同名方法导致了替换错误。

1.可能存在为了节省每次写`EffectService.GetInstance()`，自己写了个类成员的情况

![img](https://arkimg.ark.online/1697021058410-14.webp)

然后实际使用中是这么用的

![img](https://arkimg.ark.online/1697021058410-15.webp)

在自动升级后出现了代码变成`GeneralManager.rpcPlayEffectAtLocation`

```TypeScript
let play_id = this.GeneralManager.rpcPlayEffectAtLocation("86375",player_transfrom.position,0,mw.Rotation.zero,new mw.Vector(2,2,2))
```

![img](https://arkimg.ark.online/1697021058410-16.webp)

我们需要手动将其修改为`EffectService.playAtPosition`，并注意里边的参数修改后要对上

```TypeScript
let play_id = this.EffectService.playAtPosition("86375",player_transfrom.position,{loopCount:0,rotation:mw.Rotation.zero,scale:new mw.Vector(2,2,2)})
```

![img](https://arkimg.ark.online/1697021058410-17.webp)

2.用户自己写了一个setWorldLocation方法

![img](https://arkimg.ark.online/1697021058410-18.webp)

```TypeScript
// 自动升级后被修改为了，需要手动修改回去
this.worldTransform.position = player.charactre
```

3.用户自己写了一个setWholeBody方法

自动升级后被修改为

![img](https://arkimg.ark.online/1697021058410-19.webp)

需要手动将它替换回去

![img](https://arkimg.ark.online/1697021058410-20.webp)

4.用户自己写了一个名叫Events的对象

![img](https://arkimg.ark.online/1697021058410-21.webp)

自动升级后被修改为

![img](https://arkimg.ark.online/1697021058410-22.webp)

需要手动替换回去

![img](https://arkimg.ark.online/1697021058410-23.webp)

### 玩家进入离开游戏接口所在类变更

相关接口从`EventListener`修改到了`MulticastDelegate`上，如下所示修改

![img](https://arkimg.ark.online/1697021058410-24.webp)

​															**修改前**

![img](https://arkimg.ark.online/1697021058410-25.webp)

​															**修改后**

### PlayerManagerExtesion断言判断出现"never"

`PlayerManagerExtesion.isNpc(obj)`或`PlayerManagerExtesion.isCharacter(obj)`作为判断时，后面的else条件中出现了obj类型为never，如图报错显示'player' does not exist on type 'never'

原因是类型断言有误且无更好的替代方法，需要手动将原来的isNPC或者inCharacter改为对应的判断逻辑

![img](https://arkimg.ark.online/1697021058411-26.webp)

​															**修改前**

![img](https://arkimg.ark.online/1697021058411-27.webp)

​															**修改后**

### 严格编译导致的属性赋值写法错误（例如"?." ）

由于严格编译的原因，属性设置左值赋值写法会导致编译报错，改换一下写法即可

![img](https://arkimg.ark.online/1697021058411-28.webp)

​															**修改前**

![img](https://arkimg.ark.online/1697021058411-29.webp)

​															**修改后**

### 由于可见性设置从父对象获取，导致的UI显示异常

027升级之后，对象属性面板中的"可见性"设置为"从父对象获取"将生效，这可能导致项目升级后出现需要游戏中途显示的UI在一开始就显示的情况，例如：

![img](https://arkimg.ark.online/1697021058411-30.webp)

此时需要在对象管理器中找到这个UI，并且将其属性面板中的"可见性"由"从父对象获取"设置为"关闭"即可解决

![img](https://arkimg.ark.online/1697021058411-31.webp)

### 部分类构造函数被标记为私有导致

在027之前，可能有用户尝试自己再封装过代码，使其更方便于自己调用，如下图：继承SoundService并重写部分接口

![img](https://arkimg.ark.online/1697021058411-32.webp)

​															**026版本**

在027中，这种操作不可行了，不可继承并拓展

![img](https://arkimg.ark.online/1697021058411-33.webp)

​															**027版本**

### 对象非空判断连写导致报错

在027之前，部分接口有如下图中的写法，其判断character不为空然后才执行后续代码

![img](https://arkimg.ark.online/1697021058411-34.webp)

​															**026版本**

027自动升级替换方法后，这种写法会报错，需要进行修改

![img](https://arkimg.ark.online/1697021058411-35.webp)

​														**027自动升级后**

![img](https://arkimg.ark.online/1697021058411-36.webp)

​															**修改后**

### 自动化升级结束后导致复杂逻辑出现升级错误

本次升级的大部份内容编辑器会自动帮我们修改，在自动升级中有可能会因为代码中的复杂逻辑导致升级出错，有可能是语句顺序错误，也有可能出现标点、参数不正常。这时候就需要手动将其修改至正常的语句。例如：

- 升级后rpcPlayAnimation()出现语句混乱情况

```TypeScript
//升级前
this.expressUI.setCurAction(Gameplay.getCurrentPlayer().character.playAnimation("XXX", 0, 1));
//错误升级后
PlayerManagerExtesion.rpcPlayAnimation(this.expressUI.setCurAction(Player.localPlayer.character, "XXX", 0, 1));
```

此时需要查看API文档，将其修复为正确状态：

```TypeScript
//正确修改
this.expressUI.setCurAction(PlayerManagerExtesion.rpcPlayAnimation(Player.localPlayer.character,"XXX", 0, 1));
```

同样，还会出现另外一种较乱的情况

```TypeScript
//升级前
Gameplay.getPlayer(playerId).character.playAnimation("XXX",0,1)
//错误升级后
mw.getPlayerPlayerManagerExtesion.rpcPlayAnimation((playerId).character, "XXX", 0, 1);
```

恢复正常的方法也一样，需要在顺序颠倒的语句中进行排列组合，将其恢复成符合格式的语句

```TypeScript
//正确修改
PlayerManagerExtesion.rpcPlayAnimation(Player.getPlayer(playerId).character, "XXX", 0, 1);
```

### 调用AccountService.addFriend添加好友

以前传入的参数需要包含userID和openID，现在只需要传入userID即可

### CharacterBase类型升级为了Pawn

部分方法参数可能以前是CharacterBase类型，升级后(挨着instanceof 的CharacterBase都会被升级为Pawn类型，防止bug)，把Pawn对象直接传入就不行了

![img](https://arkimg.ark.online/1697021058411-37.webp)

​															**026版本**

可以修改为：

1.xxx.player.character

![img](https://arkimg.ark.online/1697021058411-38.webp)

​														**027版本修改情况1**

2.也可以修改Pawn为Character

![img](https://arkimg.ark.online/1697021058411-39.webp)

​														**027版本修改情况2**

### SystemUtil.currentPlatform枚举类型变动

以前改参数是对应的string，现在已经改为了枚举，需要做修改

![img](https://arkimg.ark.online/1697021058412-40.webp)

​															**026版本**

![img](https://arkimg.ark.online/1697021058412-41.webp)

​															**027版本**
